자료구조별 정리
**********************************************************************
# Map
#### ConcurrentHashMap
쓰기 연산이 락을 사용하여 구역화되어 있어 동시 쓰기가 가능합니다.
따라서 동시적으로 많은 스레드에서 사용되는 경우 성능이 향상됩니다.

#### ConcurrentSkipListMap
스킵 리스트는 평균적으로 O(log n)의 시간 복잡도를 가지는 탐색, 삽입, 삭제 연산을 제공합니다.

#### ConcurrentLinkedHashMap
링크드 리스트와 해시 맵을 결합한 것입니다. 
이 맵은 캐시와 같은 곳에서 많은 읽기 작업이 이루어지는 경우에 적합합니다.

#### ConcurrentLinkedHashMapV2
ConcurrentLinkedHashMap의 업그레이드 버전으로, 버전 1보다 성능과 확장성을 개선했습니다. 
이는 고성능 및 확장 가능한 애플리케이션에 유용합니다.

**********************************************************************
# Set
#### ConcurrentSkipListSet
내부적으로 ConcurrentSkipListMap을 사용하여 구현되어 있습니다.

#### CopyOnWriteArraySet
CopyOnWriteArrayList과 유사하지만 Set을 구현합니다.
요소를 추가 또는 제거할 때 내부 배열을 복사하므로 반복 작업이 많은 상황에 유용합니다.

#### ConcurrentHashSet
ConcurrentHashMap을 이용하여 스레드 안전한 Set을 만들 수 있습니다.

**********************************************************************
# ArrayList
#### CopyOnWriteArrayList
원본 리스트를 수정할 때 복사본을 만들어 수정합니다. 
따라서 반복문과 같이 읽기 작업이 많이 발생하는 상황에서 성능이 우수합니다.

**********************************************************************
# Queue
#### ConcurrentLinkedQueue
동시 쓰기와 동시 읽기가 가능하며, 너무 많은 스레드가 동시에 삭제 작업을 수행하지 않는 한 성능이 매우 우수합니다.

#### LinkedBlockingQueue
내부적으로 링크드 리스트를 기반으로 하며, 고정된 용량을 가지고 있습니다.
요소를 추가할 때 큐가 가득 찬 경우에는 쓰레드가 블로킹되어 대기하며, 요소를 제거할 때 큐가 비어있는 경우에도 마찬가지로 블로킹됩니다.

#### SynchronousQueue
이 큐는 크기가 없으며, 각 삽입 작업에는 대기하는 매칭된 쓰레드가 있어야 합니다.
일반적으로 이 큐는 한 스레드가 생성한 객체를 다른 스레드에게 전달하는 데 사용됩니다.

#### LinkedTransferQueue
다른 스레드에서 요소를 처리하거나 가져오기를 기다리는 스레드가 있는 경우에도 
즉시 요소를 제공할 수 있는 스레드 안전한 블로킹 큐입니다.

#### PriorityBlockingQueue
우선순위 큐의 스레드 안전한 구현체입니다.
요소는 우선순위에 따라 정렬되어 큐에서 꺼내집니다.

**********************************************************************
# Deque

#### ConcurrentLinkedDeque
링크드 리스트를 기반으로 하며, 큐와 스택 모두의 기능을 제공합니다.
동시 쓰기와 동시 읽기가 가능합니다.

#### LinkedBlockingDeque
LinkedBlockingQueue와 유사하지만 양 끝에서 요소를 추가하거나 제거할 수 있는 덱입니다.

#### ConcurrentLinkedBlockingDeque
ConcurrentLinkedDeque와 LinkedBlockingDeque의 기능을 결합한 것으로, 
스레드 안전한 블로킹 덱 구현체입니다.
